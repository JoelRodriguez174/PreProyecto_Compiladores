import java_cup.runtime.*;
import java.util.*;

parser code {:
    public void report_error(String message, Object info) {
        System.err.println("Error sintáctico: " + message);
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            System.err.println("En línea: " + (s.left + 1) + ", columna: " + (s.right + 1));
        }
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:}

/* === TERMINALES === */
terminal String IDENTIFICADOR;
terminal String NUMERO;
terminal INT, BOOL, VOID, MAIN, RETURN;
terminal IF, THEN, ELSE, WHILE;
terminal TRUE, FALSE;
terminal OPERADOR_ASIGNACION, OPERADOR_SUMA, OPERADOR_RESTA, OPERADOR_MULTIPLICACION, OPERADOR_DIVISION, OPERADOR_MODULO;
terminal OPERADOR_MENOR, OPERADOR_MAYOR, OPERADOR_IGUALDAD;
terminal OPERADOR_AND, OPERADOR_OR, OPERADOR_NOT;
terminal PARENTESIS_ABRE, PARENTESIS_CIERRA, LLAVE_ABRE, LLAVE_CIERRA, PUNTO_COMA;

/* === NO TERMINALES === */
non terminal Nodo Programa;
non terminal Nodo TipoMain;
non terminal Nodo Bloque;
non terminal Nodo Declaraciones;
non terminal Nodo Declaracion;
non terminal Nodo Tipo;
non terminal Nodo Sentencias;
non terminal Nodo Sentencia;
non terminal Nodo Asignacion;
non terminal Nodo Return;
non terminal Nodo Expresion;
non terminal Nodo Factor;

/* === PRECEDENCIA === */
precedence left OPERADOR_OR;
precedence left OPERADOR_AND;
precedence left OPERADOR_IGUALDAD;
precedence left OPERADOR_MENOR, OPERADOR_MAYOR;
precedence left OPERADOR_SUMA, OPERADOR_RESTA;
precedence left OPERADOR_MULTIPLICACION, OPERADOR_DIVISION, OPERADOR_MODULO;
precedence left ELSE;
precedence right OPERADOR_NOT;

/* === PUNTO DE INICIO === */
start with Programa;

/* === PRODUCCIONES === */

Programa ::= TipoMain:tm MAIN:m PARENTESIS_ABRE PARENTESIS_CIERRA Bloque:bloq
    {:
        Nodo prog = new Nodo("Programa", null, mleft, mright);
        prog.agregarHijo(tm);
        prog.agregarHijo(new Nodo("Main", null, mleft, mright));
        prog.agregarHijo(bloq);
        RESULT = prog;
    :}
;

TipoMain ::= VOID:v
    {: RESULT = new Nodo("TipoMain","void", vleft, vright); :}
    | INT:i
    {: RESULT = new Nodo("TipoMain","int", ileft, iright); :}
    | BOOL:b
    {: RESULT = new Nodo("TipoMain","bool", bleft, bright); :}
;

Bloque ::= LLAVE_ABRE Declaraciones:decls Sentencias:stmts LLAVE_CIERRA
    {:
        Nodo bloque = new Nodo("Bloque", null, decls.linea, decls.columna);
        bloque.agregarHijo(decls);
        bloque.agregarHijo(stmts);
        RESULT = bloque;
    :}
;

Declaraciones ::= Declaracion:d Declaraciones:ds
    {:
        Nodo lista = new Nodo("Declaraciones", null, d.linea, d.columna);
        lista.agregarHijo(d);
        lista.agregarHijo(ds);
        RESULT = lista;
    :}
    | /* epsilon */
    {: RESULT = new Nodo("Declaraciones"); :}
;

Declaracion ::= Tipo:t IDENTIFICADOR:id PUNTO_COMA
    {:
        Nodo decl = new Nodo("Declaracion", null, idleft, idright);
        decl.agregarHijo(t);
        decl.agregarHijo(new Nodo("Identificador", id, idleft, idright));
        RESULT = decl;
    :}
    | Tipo:t IDENTIFICADOR:id OPERADOR_ASIGNACION Expresion:e PUNTO_COMA
    {:
        Nodo decl = new Nodo("Declaracion", null, idleft, idright);
        decl.agregarHijo(t);
        decl.agregarHijo(new Nodo("Identificador", id, idleft, idright));
        decl.agregarHijo(e);
        RESULT = decl;
    :}
;

Tipo ::= INT:i
    {: RESULT = new Nodo("Tipo","int", ileft, iright); :}
    | BOOL:b
    {: RESULT = new Nodo("Tipo","bool", bleft, bright); :}
;

Sentencias ::= Sentencia:s Sentencias:ss
    {:
        Nodo lista = new Nodo("Sentencias", null, s.linea, s.columna);
        lista.agregarHijo(s);
        lista.agregarHijo(ss);
        RESULT = lista;
    :}
    | /* epsilon */
    {: RESULT = new Nodo("Sentencias"); :}
;

Sentencia ::= Asignacion:a
    {: RESULT = a; :}
    | Return:r
    {: RESULT = r; :}
    | IF:iff PARENTESIS_ABRE Expresion:cond PARENTESIS_CIERRA THEN:t Sentencia:s1
          {:
              Nodo ifn = new Nodo("If", null, cond.linea, cond.columna);
              ifn.agregarHijo(cond);
              ifn.agregarHijo(s1);
              RESULT = ifn;
          :}
    | IF:iff PARENTESIS_ABRE Expresion:cond PARENTESIS_CIERRA THEN:t Sentencia:s1 ELSE:e Sentencia:s2
          {:
              Nodo ifelse = new Nodo("If", null, cond.linea, cond.columna);
              ifelse.agregarHijo(cond);
              ifelse.agregarHijo(s1);
              ifelse.agregarHijo(s2);
              RESULT = ifelse;
          :}
    | WHILE:w PARENTESIS_ABRE Expresion:cond PARENTESIS_CIERRA Sentencia:s
        {:
            Nodo whileN = new Nodo("While", null, cond.linea, cond.columna);
            whileN.agregarHijo(cond);
            whileN.agregarHijo(s);
            RESULT = whileN;
        :}
    | Bloque:b
        {: RESULT = b; :}
;

Asignacion ::= IDENTIFICADOR:id OPERADOR_ASIGNACION Expresion:expr PUNTO_COMA
    {:
        Nodo asign = new Nodo("Asignacion", null, idleft, idright);
        asign.agregarHijo(new Nodo("Identificador", id, idleft, idright));
        asign.agregarHijo(expr);
        RESULT = asign;
    :}
;

Return ::= RETURN:r Expresion:e PUNTO_COMA
    {:
        Nodo ret = new Nodo("Return", null, rleft, rright);
        ret.agregarHijo(e);
        RESULT = ret;
    :}
    | RETURN:r PUNTO_COMA
    {:
        RESULT = new Nodo("Return","void", rleft, rright);
    :}
;

/* === Expresiones === */

Expresion ::=
      Expresion:e1 OPERADOR_SUMA:s Expresion:e2
        {: Nodo n = new Nodo("Suma", null, sleft, sright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_RESTA:r Expresion:e2
        {: Nodo n = new Nodo("Resta", null, rleft, rright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_MULTIPLICACION:m Expresion:e2
        {: Nodo n = new Nodo("Multiplicacion", null, mleft, mright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_DIVISION:d Expresion:e2
        {: Nodo n = new Nodo("Division", null, dleft, dright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_MODULO:mod Expresion:e2
        {: Nodo n = new Nodo("Modulo", null, modleft, modright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_MENOR:men Expresion:e2
        {: Nodo n = new Nodo("Menor", null, menleft, menright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_MAYOR:may Expresion:e2
        {: Nodo n = new Nodo("Mayor", null, mayleft, mayright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_IGUALDAD:eq Expresion:e2
        {: Nodo n = new Nodo("Igual", null, eqleft, eqright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_AND:a Expresion:e2
        {: Nodo n = new Nodo("And", null, aleft, aright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | Expresion:e1 OPERADOR_OR:o Expresion:e2
        {: Nodo n = new Nodo("Or", null, oleft, oright);
           n.agregarHijo(e1); n.agregarHijo(e2); RESULT = n; :}
    | OPERADOR_NOT:n Expresion:e
        {: Nodo n2 = new Nodo("Not", null, nleft, nright);
           n2.agregarHijo(e); RESULT = n2; :}
    | OPERADOR_RESTA:r Factor:f
        {: Nodo n = new Nodo("MenosUnario", null, rleft, rright);
           n.agregarHijo(f); RESULT = n; :}
    | PARENTESIS_ABRE Expresion:e PARENTESIS_CIERRA
        {: RESULT = e; :}
    | NUMERO:num
        {: RESULT = new Nodo("Numero", num, numleft, numright); :}
    | IDENTIFICADOR:id
        {: RESULT = new Nodo("Identificador", id, idleft, idright); :}
    | TRUE:t
        {: RESULT = new Nodo("True","true", tleft, tright); :}
    | FALSE:f
        {: RESULT = new Nodo("False","false", fleft, fright); :}
;